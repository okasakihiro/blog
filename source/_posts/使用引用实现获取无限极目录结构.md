---
title: 使用引用实现获取无限极目录结构
date: 2019/8/8 20:09
categories: 后端
tag: [PHP, 数据结构]
toc: true
---

> 无限极目录在分类/条件列表中非常常见，以前采用递归思想就可以解决，后来无意中发现一种通过PHP引用机制来实现的方法。最近又有类似的开发需求，这次讲一下具体的实现原理。

# 构建数据
首先来构建数据：
```PHP
$category = [
    [
        'id'   => 1,
        'pid'  => 0,
        'name' => '家居用品',
    ],
    [
        'id'   => 2,
        'pid'  => 1,
        'name' => '餐厅用品',
    ],
    [
        'id'   => 3,
        'pid'  => 2,
        'name' => '酒具',
    ],
    [
        'id'   => 4,
        'pid'  => 1,
        'name' => '卫浴用品',
    ],
];
```

防止篇幅过长，在这里暂定义三层结构。
用过的人都知道，无限极目录的最后结构实际上就是一个树形结构。
将上面的数据转化为无限极目录后的数据结构：
```PHP
$category = [
    [
        'id'   => 1,
        'pid'  => 0,
        'name' => '家居用品',
        'children' => [
            [
                'id'   => 2,
                'pid'  => 1,
                'name' => '餐厅用品',
                'children' => [
                    [
                        'id'   => 3,
                        'pid'  => 2,
                        'name' => '酒具',
                    ]
                ],
            ],
            [
                'id'   => 4,
                'pid'  => 1,
                'name' => '卫浴用品',
            ],
        ],
    ]
];
```
下面我们来结合代码讲一下具体原理。

# 代码实现
先上代码，然后再来将具体实现，整个过程分为两部分组成：
1. ```PHP
   $categoriesStructure = [];
   foreach($categories as $category) {
       $categoriesStructure[$category['id']] = $category;
   }
   unset($category);
   ```
2. ```PHP
   $categoryTree = [];
        foreach ($categoriesStructure as $key => $  category) {
            //判断当前结构体重是否存在第一次遍历数据的 pid
            if (isset($categoriesStructure[$category['pid']])) {
                //如果存在则在父数据中引用当前数据作为子数据，添加到子数组中。
                //该部分逻辑不受层数控制：原因在于子数据有可能是存在孙子数据，
                //但遍历到孙子数据的时候，子数据相当于父数据，孙子数据相当于子数据，
                //这样采用引用的时候，最初的父数据中也会引入孙子数据，从而实现整个逻辑。
                $categoriesStructure[$category['pid']]['children'][] = &$categoriesStructure[$key];
            } else {
                //由于原数据中存有所有的数据，所以需要重新穿件一个数组。
                //同时由于引用中的数据会随着遍历过程发生变化，
                //故将不符合条件的数据押入数组时，也需要通过引用，
                //这样在后续遍历押入子数据/孙子数据时，被引用的数据也会发生改变
                $categoryTree[] = &$categoriesStructure[$key];
            }
        }
   ```

# 实现原理
同样，这里也分上下两部分讲：

1. 第一部分的内容并不复杂，目的是为了暴露自身ID，以便于第二部分进行判断和提取。
2. 由于所有数据的 key 为自身 id ，所以使用 isset 来判断数据中是否存在当前数据的 pid（也可以使用 array_key_exsits() 函数）
   
   当判断为 true 时，在当前数据中创建 children 字段数组。采用引用的方式将符合条件的数据押入 children 数组中。
   
   由于采用的是引用，所以访问的是同一个变量内容。
   
   每次循环都会寻找是否存在 pid ，如果有，将 children 中加入引用。
   
   关系：父级->引用子级->引用孙子级...
   
   那么在修改子级的时候，由于父级中保存的是子级的引用，所以在子级中添加引用的孙子级时，父级中的内容也会发生变化(即在父级的子级中添加了孙子级)当判断为 false ，则证明当前数据是父级，此时引用存入树形结构数组，保证新数组中只有从父级开始的树形结构。
   
   重点：此时的任何修改也会影响树形结构数组中的内容，原因是数据之间都是通过引用来实现的。

   至此，通过引用实现获取无限极目录机构的完成。

   总体原理就是通过操作引用数据的同时，原数据也会发生变化。